<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gen: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/KaranAhlawat/ddgf/internal/repo/gen/advice.sql.go (92.6%)</option>
				
				<option value="file1">github.com/KaranAhlawat/ddgf/internal/repo/gen/advice_tag.sql.go (76.5%)</option>
				
				<option value="file2">github.com/KaranAhlawat/ddgf/internal/repo/gen/db.go (50.0%)</option>
				
				<option value="file3">github.com/KaranAhlawat/ddgf/internal/repo/gen/page.sql.go (92.6%)</option>
				
				<option value="file4">github.com/KaranAhlawat/ddgf/internal/repo/gen/tag.sql.go (92.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: advice.sql

package db

import (
        "context"

        "github.com/google/uuid"
)

const deleteAdvice = `-- name: DeleteAdvice :exec
DELETE FROM "advices"
WHERE "id" = $1
`

func (q *Queries) DeleteAdvice(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        _, err := q.db.ExecContext(ctx, deleteAdvice, id)
        return err
}</span>

const insertAdvice = `-- name: InsertAdvice :one
INSERT INTO "advices" ("id", "content")
VALUES ($1, $2)
RETURNING id, content
`

type InsertAdviceParams struct {
        Content string    `json:"content"`
        ID      uuid.UUID `json:"id"`
}

func (q *Queries) InsertAdvice(ctx context.Context, arg InsertAdviceParams) (Advice, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, insertAdvice, arg.ID, arg.Content)
        var i Advice
        err := row.Scan(&amp;i.ID, &amp;i.Content)
        return i, err
}</span>

const selectAdvice = `-- name: SelectAdvice :one
SELECT id, content
FROM "advices"
WHERE "id" = $1
LIMIT 1
`

func (q *Queries) SelectAdvice(ctx context.Context, id uuid.UUID) (Advice, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, selectAdvice, id)
        var i Advice
        err := row.Scan(&amp;i.ID, &amp;i.Content)
        return i, err
}</span>

const selectAdvices = `-- name: SelectAdvices :many
SELECT id, content
FROM "advices"
ORDER BY "id"
`

func (q *Queries) SelectAdvices(ctx context.Context) ([]Advice, error) <span class="cov8" title="1">{
        rows, err := q.db.QueryContext(ctx, selectAdvices)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Advice{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Advice
                if err := rows.Scan(&amp;i.ID, &amp;i.Content); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const updateAdvice = `-- name: UpdateAdvice :exec
UPDATE "advices"
SET "content" = $1
WHERE "id" = $2
`

type UpdateAdviceParams struct {
        Content string    `json:"content"`
        ID      uuid.UUID `json:"id"`
}

func (q *Queries) UpdateAdvice(ctx context.Context, arg UpdateAdviceParams) error <span class="cov8" title="1">{
        _, err := q.db.ExecContext(ctx, updateAdvice, arg.Content, arg.ID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: advice_tag.sql

package db

import (
        "context"

        "github.com/google/uuid"
)

const deleteTagFromAdvice = `-- name: DeleteTagFromAdvice :exec
DELETE FROM "advices_tags"
WHERE "advice_id" = $1
    AND "tag_id" = $2
`

type DeleteTagFromAdviceParams struct {
        AdviceID uuid.UUID `json:"advice_id"`
        TagID    uuid.UUID `json:"tag_id"`
}

func (q *Queries) DeleteTagFromAdvice(ctx context.Context, arg DeleteTagFromAdviceParams) error <span class="cov8" title="1">{
        _, err := q.db.ExecContext(ctx, deleteTagFromAdvice, arg.AdviceID, arg.TagID)
        return err
}</span>

const insertAdviceTagEntry = `-- name: InsertAdviceTagEntry :one
INSERT INTO "advices_tags" ("advice_id", "tag_id")
    VALUES ($1, $2)
RETURNING
    advice_id, tag_id
`

type InsertAdviceTagEntryParams struct {
        AdviceID uuid.UUID `json:"advice_id"`
        TagID    uuid.UUID `json:"tag_id"`
}

func (q *Queries) InsertAdviceTagEntry(ctx context.Context, arg InsertAdviceTagEntryParams) (AdvicesTag, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, insertAdviceTagEntry, arg.AdviceID, arg.TagID)
        var i AdvicesTag
        err := row.Scan(&amp;i.AdviceID, &amp;i.TagID)
        return i, err
}</span>

const selectAdvicesForTag = `-- name: SelectAdvicesForTag :many
SELECT
    "at"."advice_id",
    "a"."content"
FROM
    "advices_tags" "at"
    JOIN "advices" "a" ON "at"."advice_id" = "a"."id"
WHERE
    "at"."tag_id" = $1
`

type SelectAdvicesForTagRow struct {
        Content  string    `json:"content"`
        AdviceID uuid.UUID `json:"advice_id"`
}

func (q *Queries) SelectAdvicesForTag(ctx context.Context, tagID uuid.UUID) ([]SelectAdvicesForTagRow, error) <span class="cov8" title="1">{
        rows, err := q.db.QueryContext(ctx, selectAdvicesForTag, tagID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []SelectAdvicesForTagRow{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i SelectAdvicesForTagRow
                if err := rows.Scan(&amp;i.AdviceID, &amp;i.Content); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const selectAllEntries = `-- name: SelectAllEntries :many
SELECT
    advice_id, tag_id
FROM
    "advices_tags"
ORDER BY
    "advice_id"
`

func (q *Queries) SelectAllEntries(ctx context.Context) ([]AdvicesTag, error) <span class="cov8" title="1">{
        rows, err := q.db.QueryContext(ctx, selectAllEntries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []AdvicesTag{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i AdvicesTag
                if err := rows.Scan(&amp;i.AdviceID, &amp;i.TagID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const selectTagsForAdvice = `-- name: SelectTagsForAdvice :many
SELECT
    "at"."tag_id",
    "t"."tag"
FROM
    "advices_tags" "at"
    JOIN "tags" "t" ON "at"."tag_id" = "t"."id"
WHERE
    "at"."advice_id" = $1
`

type SelectTagsForAdviceRow struct {
        Tag   string    `json:"tag"`
        TagID uuid.UUID `json:"tag_id"`
}

func (q *Queries) SelectTagsForAdvice(ctx context.Context, adviceID uuid.UUID) ([]SelectTagsForAdviceRow, error) <span class="cov8" title="1">{
        rows, err := q.db.QueryContext(ctx, selectTagsForAdvice, adviceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []SelectTagsForAdviceRow{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i SelectTagsForAdviceRow
                if err := rows.Scan(&amp;i.TagID, &amp;i.Tag); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0

package db

import (
        "context"
        "database/sql"
)

type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: page.sql

package db

import (
        "context"
        "time"

        "github.com/google/uuid"
)

const deletePage = `-- name: DeletePage :exec
DELETE FROM "pages"
WHERE "id" = $1
`

func (q *Queries) DeletePage(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        _, err := q.db.ExecContext(ctx, deletePage, id)
        return err
}</span>

const insertPage = `-- name: InsertPage :one
INSERT INTO "pages" ("id", "datetime", "content")
VALUES ($1, $2, $3)
RETURNING id, datetime, content
`

type InsertPageParams struct {
        Datetime time.Time `json:"datetime"`
        Content  string    `json:"content"`
        ID       uuid.UUID `json:"id"`
}

func (q *Queries) InsertPage(ctx context.Context, arg InsertPageParams) (Page, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, insertPage, arg.ID, arg.Datetime, arg.Content)
        var i Page
        err := row.Scan(&amp;i.ID, &amp;i.Datetime, &amp;i.Content)
        return i, err
}</span>

const selectPage = `-- name: SelectPage :one
SELECT id, datetime, content
FROM "pages"
WHERE "id" = $1
LIMIT 1
`

func (q *Queries) SelectPage(ctx context.Context, id uuid.UUID) (Page, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, selectPage, id)
        var i Page
        err := row.Scan(&amp;i.ID, &amp;i.Datetime, &amp;i.Content)
        return i, err
}</span>

const selectPages = `-- name: SelectPages :many
SELECT id, datetime, content
FROM "pages"
ORDER BY "datetime"
`

func (q *Queries) SelectPages(ctx context.Context) ([]Page, error) <span class="cov8" title="1">{
        rows, err := q.db.QueryContext(ctx, selectPages)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Page{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Page
                if err := rows.Scan(&amp;i.ID, &amp;i.Datetime, &amp;i.Content); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}

const updatePage = `-- name: UpdatePage :exec
UPDATE "pages"
SET "content" = $1,
"datetime" = $2
WHERE "id" = $3
`

type UpdatePageParams struct {
        Content  string    `json:"content"`
        Datetime time.Time `json:"datetime"`
        ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdatePage(ctx context.Context, arg UpdatePageParams) error <span class="cov8" title="1">{
        _, err := q.db.ExecContext(ctx, updatePage, arg.Content, arg.Datetime, arg.ID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: tag.sql

package db

import (
        "context"

        "github.com/google/uuid"
)

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM "tags"
WHERE "id" = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        _, err := q.db.ExecContext(ctx, deleteTag, id)
        return err
}</span>

const insertTag = `-- name: InsertTag :one
INSERT INTO "tags" ("id", "tag")
VALUES ($1, $2)
RETURNING id, tag
`

type InsertTagParams struct {
        Tag string    `json:"tag"`
        ID  uuid.UUID `json:"id"`
}

func (q *Queries) InsertTag(ctx context.Context, arg InsertTagParams) (Tag, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, insertTag, arg.ID, arg.Tag)
        var i Tag
        err := row.Scan(&amp;i.ID, &amp;i.Tag)
        return i, err
}</span>

const selectTag = `-- name: SelectTag :one
SELECT id, tag
FROM "tags"
WHERE "id" = $1
LIMIT 1
`

func (q *Queries) SelectTag(ctx context.Context, id uuid.UUID) (Tag, error) <span class="cov8" title="1">{
        row := q.db.QueryRowContext(ctx, selectTag, id)
        var i Tag
        err := row.Scan(&amp;i.ID, &amp;i.Tag)
        return i, err
}</span>

const selectTags = `-- name: SelectTags :many
SELECT id, tag
FROM "tags"
ORDER BY "tag"
`

func (q *Queries) SelectTags(ctx context.Context) ([]Tag, error) <span class="cov8" title="1">{
        rows, err := q.db.QueryContext(ctx, selectTags)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        items := []Tag{}
        for rows.Next() </span><span class="cov8" title="1">{
                var i Tag
                if err := rows.Scan(&amp;i.ID, &amp;i.Tag); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, i)</span>
        }
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
